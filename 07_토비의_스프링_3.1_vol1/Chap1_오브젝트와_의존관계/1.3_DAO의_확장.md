# 1.3 DAO의 확장

- 오브젝트는 관심사에 따라 제각기 독특한 특징을 바탕으로 변화함

  → 변화의 이유, 시기, 주기가 다름

- 추상 클래스를 만들고 이를 상속한 서브클래스를 바꿔줌 (단, 이를 상속으로 푸는건 별로인 듯)

## 1.3.1 클래스의 분리

![Untitled](../img/Chap1/Untitled%205.png)

- 상속 관계도 아닌 완전히 독립적인 클래스
- UserDao는 상속을 통한 방법을 쓰지 않아 abstract일 필요가 없음

그러나 UserDao가 SimpleConnectionMaker 라는 특정 클래스와 코드에 종속적이면 확장이 불가

## 1.3.2 인터페이스의 도입

![Untitled](../img/Chap1/Untitled%206.png)

- 중간에 추상적인 느슨한 연결고리 생성

  ⇒ **인터페이스**(구현 방법은 나타나지 않음, 구체적인 정보는 모두 감춤)

- 추상화 : 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리함
- 클래스와 인터페이스를 전달하면, 인터페이스를 구현한 클래스는 각자 만들면 된다

- 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자 코드는 제거되지 않음

## 1.3.3 관계설정 책임의 분리

- 어떤 `ConnectionMaker` 구현 클래스의 오브젝트를 이용하게 할지를 결정
    - 서비스 : 사용되는 오브젝트
    - 클라이언트 : 사용하는 오브젝트

  ⇒ 오브젝트와 오브젝트 사이의 관계 설정 필요


![Untitled](../img/Chap1/Untitled%208.png)

- 다형성
    - 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능
    

- UserDao에 있으면 안 되는 다른 관심사항, 책임을 클라이언트로 떠넘김
- UserDao와 ConnectionMaker 클래스들을 분리하고 서로 영향을 주지 않으면서 필요에 따라 확장 가능

## 1.3.4 원칙과 패턴

- 개방 폐쇄 원칙
    - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다

      ![Untitled](../img/Chap1/Untitled%2010.png)

    - 클래스는 변경 X, 인터페이스 구현체를 통한 변경
    - 대부분의 API

  [객체지향 설계 원칙 (SOLID)](https://www.notion.so/SOLID-f682d71b9cdd40058f741bc67adb7167)

- 높은 응집도와 낮은 결합도
    - 높은 응집도 : 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중 되어있음 (클래스, 패키지, 컴포넌트, 모듈에도 다 적용 가능)
    - 낮은 결합도 : 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지함
- 전략 패턴
    - 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
    - 대체 가능한 전략
    - 클라이언트의 역할에 대해서도 설명할 수 있음
    - 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략(ConnectionMaker 구현체, DConnectionMaker)을 컨텍스트의 생성자 등을 통해 제공
